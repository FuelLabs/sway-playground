{
  "sway": [
    {
      "name": "Counter",
      "filename": "Counter.sw",
      "code": "contract;\n\n abi Counter {\n    #[storage(read, write)]\n    fn increment(amount: u64) -> u64;\n\n    #[storage(read)]\n    fn get() -> u64;\n}\n\nstorage {\n    counter: u64 = 0,\n}\n\nimpl Counter for Contract {\n    #[storage(read, write)]\n    fn increment(amount: u64) -> u64 {\n        let incremented = storage.counter.read() + amount;\n        storage.counter.write(incremented);\n        incremented\n    }\n\n    #[storage(read)]\n    fn get() -> u64 {\n        storage.counter.read()\n    }\n}"
    },
    {
      "name": "LiquidityPool",
      "filename": "LiquidityPool.sw",
      "code": "contract;\n \nuse std::{\n    asset::{\n        mint_to,\n        transfer,\n    },\n    call_frames::msg_asset_id,\n    constants::DEFAULT_SUB_ID,\n    context::msg_amount\n};\n \n abi LiquidityPool {\n    fn deposit(recipient: Address);\n    fn withdraw(recipient: Address);\n}\n \nconst BASE_ASSET: AssetId = AssetId::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);\n \nimpl LiquidityPool for Contract {\n    fn deposit(recipient: Address) {\n        assert(msg_asset_id() == BASE_ASSET);\n        assert(msg_amount() > 0);\n \n        // Mint two times the amount.\n        let amount_to_mint = msg_amount() * 2;\n \n        // Mint some LP assets based upon the amount of the base asset.\n        mint_to(Identity::Address(recipient), DEFAULT_SUB_ID, amount_to_mint);\n    }\n \n    fn withdraw(recipient: Address) {\n        let asset_id = AssetId::default();\n        assert(msg_asset_id() == asset_id);\n        assert(msg_amount() > 0);\n \n        // Amount to withdraw.\n        let amount_to_transfer = msg_amount() / 2;\n \n        // Transfer base asset to recipient.\n        transfer(Identity::Address(recipient), BASE_ASSET, amount_to_transfer);\n    }\n}"
    },
    {
      "name": "SingleAsset",
      "filename": "SingleAsset.sw",
      "code": "// ERC20 equivalent in Sway.\ncontract;\n\nuse src3::SRC3;\nuse src5::{AccessError, SRC5, State};\nuse src20::{SetDecimalsEvent, SetNameEvent, SetSymbolEvent, SRC20, TotalSupplyEvent};\nuse std::{\n    asset::{\n        burn,\n        mint_to,\n    },\n    call_frames::{\n        msg_asset_id,\n    },\n    constants::DEFAULT_SUB_ID,\n    context::msg_amount,\n    string::String,\n};\n\n abi SingleAsset {\n    #[storage(read, write)]\n    fn constructor(owner_: Identity);\n}\n\nconfigurable {\n    DECIMALS: u8 = 9u8,\n    NAME: str[7] = __to_str_array(\"MyAsset\"),\n    SYMBOL: str[5] = __to_str_array(\"MYTKN\"),\n}\n\nstorage {\n    total_supply: u64 = 0,\n    owner: State = State::Uninitialized,\n}\n\nimpl SRC20 for Contract {\n    #[storage(read)]\n    fn total_assets() -> u64 {\n        1\n    }\n\n    #[storage(read)]\n    fn total_supply(asset: AssetId) -> Option<u64> {\n        if asset == AssetId::default() {\n            Some(storage.total_supply.read())\n        } else {\n            None\n        }\n    }\n\n    #[storage(read)]\n    fn name(asset: AssetId) -> Option<String> {\n        if asset == AssetId::default() {\n            Some(String::from_ascii_str(from_str_array(NAME)))\n        } else {\n            None\n        }\n    }\n\n    #[storage(read)]\n    fn symbol(asset: AssetId) -> Option<String> {\n        if asset == AssetId::default() {\n            Some(String::from_ascii_str(from_str_array(SYMBOL)))\n        } else {\n            None\n        }\n    }\n\n    #[storage(read)]\n    fn decimals(asset: AssetId) -> Option<u8> {\n        if asset == AssetId::default() {\n            Some(DECIMALS)\n        } else {\n            None\n        }\n    }\n}\n\n#[storage(read)]\nfn require_access_owner() {\n    require(\n        storage\n            .owner\n            .read() == State::Initialized(msg_sender().unwrap()),\n        AccessError::NotOwner,\n    );\n}\n\nimpl SingleAsset for Contract {\n    #[storage(read, write)]\n    fn constructor(owner_: Identity) {\n        require(\n            storage\n                .owner\n                .read() == State::Uninitialized,\n            \"owner-initialized\",\n        );\n        storage.owner.write(State::Initialized(owner_));\n    }\n}\n\nimpl SRC5 for Contract {\n    #[storage(read)]\n    fn owner() -> State {\n        storage.owner.read()\n    }\n}\n\nimpl SRC3 for Contract {\n    #[storage(read, write)]\n    fn mint(recipient: Identity, sub_id: Option<SubId>, amount: u64) {\n        require(sub_id.is_some() && sub_id.unwrap() == DEFAULT_SUB_ID, \"incorrect-sub-id\");\n        require_access_owner();\n\n        let current_supply = storage.total_supply.read();\n        storage\n            .total_supply\n            .write(current_supply + amount);\n        mint_to(recipient, DEFAULT_SUB_ID, amount);\n        TotalSupplyEvent::new(AssetId::default(), current_supply + amount, msg_sender().unwrap()).log();\n    }\n\n    #[payable]\n    #[storage(read, write)]\n    fn burn(sub_id: SubId, amount: u64) {\n        require(sub_id == DEFAULT_SUB_ID, \"incorrect-sub-id\");\n        require(msg_amount() >= amount, \"incorrect-amount-provided\");\n        require(\n            msg_asset_id() == AssetId::default(),\n            \"incorrect-asset-provided\",\n        );\n        require_access_owner();\n\n        let current_supply = storage.total_supply.read();\n        storage\n            .total_supply\n            .write(current_supply - amount);\n        burn(DEFAULT_SUB_ID, amount);\n        TotalSupplyEvent::new(AssetId::default(), current_supply - amount, msg_sender().unwrap()).log();\n    }\n}\n\n abi EmitSRC20Events {\n    fn emit_src20_events();\n}\n\nimpl EmitSRC20Events for Contract {\n    fn emit_src20_events() {\n        // Metadata that is stored as a configurable should only be emitted once.\n        let asset = AssetId::default();\n        let sender = msg_sender().unwrap();\n        let name = Some(String::from_ascii_str(from_str_array(NAME)));\n        let symbol = Some(String::from_ascii_str(from_str_array(SYMBOL)));\n\n        SetNameEvent::new(asset, name, sender).log();\n        SetSymbolEvent::new(asset, symbol, sender).log();\n        SetDecimalsEvent::new(asset, DECIMALS, sender).log();\n    }\n}"
    },
    {
      "name": "MultiAsset",
      "filename": "MultiAsset.sw",
      "code": "// ERC1155 equivalent in Sway.\ncontract;\n\nuse src5::{AccessError, SRC5, State};\nuse src20::{SetDecimalsEvent, SetNameEvent, SetSymbolEvent, SRC20, TotalSupplyEvent};\nuse src3::SRC3;\nuse std::{\n    asset::{\n        burn,\n        mint_to,\n    },\n    call_frames::msg_asset_id,\n    context::this_balance,\n    hash::{\n        Hash,\n    },\n    storage::storage_string::*,\n    string::String,\n};\n\nstorage {\n    total_assets: u64 = 0,\n    total_supply: StorageMap<AssetId, u64> = StorageMap {},\n    name: StorageMap<AssetId, StorageString> = StorageMap {},\n    symbol: StorageMap<AssetId, StorageString> = StorageMap {},\n    decimals: StorageMap<AssetId, u8> = StorageMap {},\n    owner: State = State::Uninitialized,\n}\n\n abi MultiAsset {\n    #[storage(read, write)]\n    fn constructor(owner_: Identity);\n\n    #[storage(read, write)]\n    fn set_name(asset: AssetId, name: String);\n\n    #[storage(read, write)]\n    fn set_symbol(asset: AssetId, symbol: String);\n\n    #[storage(read, write)]\n    fn set_decimals(asset: AssetId, decimals: u8);\n}\n\nimpl MultiAsset for Contract {\n    #[storage(read, write)]\n    fn constructor(owner_: Identity) {\n        require(\n            storage\n                .owner\n                .read() == State::Uninitialized,\n            \"owner-initialized\",\n        );\n        storage.owner.write(State::Initialized(owner_));\n    }\n\n    #[storage(read, write)]\n    fn set_name(asset: AssetId, name: String) {\n        require_access_owner();\n        storage.name.insert(asset, StorageString {});\n        storage.name.get(asset).write_slice(name);\n        SetNameEvent::new(asset, Some(name), msg_sender().unwrap()).log();\n    }\n\n    #[storage(read, write)]\n    fn set_symbol(asset: AssetId, symbol: String) {\n        require_access_owner();\n        storage.symbol.insert(asset, StorageString {});\n        storage.symbol.get(asset).write_slice(symbol);\n        SetSymbolEvent::new(asset, Some(symbol), msg_sender().unwrap()).log();\n    }\n\n    #[storage(read, write)]\n    fn set_decimals(asset: AssetId, decimals: u8) {\n        require_access_owner();\n        storage.decimals.insert(asset, decimals);\n        SetDecimalsEvent::new(asset, decimals, msg_sender().unwrap()).log();\n    }\n}\n\n#[storage(read)]\nfn require_access_owner() {\n    require(\n        storage\n            .owner\n            .read() == State::Initialized(msg_sender().unwrap()),\n        AccessError::NotOwner,\n    );\n}\n\nimpl SRC20 for Contract {\n    #[storage(read)]\n    fn total_assets() -> u64 {\n        storage.total_assets.read()\n    }\n\n    #[storage(read)]\n    fn total_supply(asset: AssetId) -> Option<u64> {\n        storage.total_supply.get(asset).try_read()\n    }\n\n    #[storage(read)]\n    fn name(asset: AssetId) -> Option<String> {\n        storage.name.get(asset).read_slice()\n    }\n\n    #[storage(read)]\n    fn symbol(asset: AssetId) -> Option<String> {\n        storage.symbol.get(asset).read_slice()\n    }\n\n    #[storage(read)]\n    fn decimals(asset: AssetId) -> Option<u8> {\n        storage.decimals.get(asset).try_read()\n    }\n}\n\nimpl SRC3 for Contract {\n    #[storage(read, write)]\n    fn mint(recipient: Identity, sub_id: Option<SubId>, amount: u64) {\n        require_access_owner();\n        let sub_id = match sub_id {\n            Some(id) => id,\n            None => SubId::zero(),\n        };\n        let asset_id = AssetId::new(ContractId::this(), sub_id);\n        let supply = storage.total_supply.get(asset_id).try_read();\n        if supply.is_none() {\n            storage\n                .total_assets\n                .write(storage.total_assets.try_read().unwrap_or(0) + 1);\n        }\n        let current_supply = supply.unwrap_or(0);\n        storage\n            .total_supply\n            .insert(asset_id, current_supply + amount);\n        mint_to(recipient, sub_id, amount);\n        TotalSupplyEvent::new(asset_id, current_supply + amount, msg_sender().unwrap()).log();\n    }\n\n    #[payable]\n    #[storage(read, write)]\n    fn burn(sub_id: SubId, amount: u64) {\n        require_access_owner();\n        let asset_id = AssetId::new(ContractId::this(), sub_id);\n        require(this_balance(asset_id) >= amount, \"not-enough-coins\");\n\n        let supply = storage.total_supply.get(asset_id).try_read();\n        let current_supply = supply.unwrap_or(0);\n        storage\n            .total_supply\n            .insert(asset_id, current_supply - amount);\n        burn(sub_id, amount);\n        TotalSupplyEvent::new(asset_id, current_supply - amount, msg_sender().unwrap()).log();\n    }\n}"
    }
  ]
}